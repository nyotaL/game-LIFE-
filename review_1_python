# импорт нужных библиотек
import pygame
import random

# определяем параметры и дизайн поля, его компонент. Учитываем, что можем захотеть их поменять
SCREEN_X = 1300
SCREEN_Y = 850
CELL_SIZE = 10
FONT_SIZE = max(CELL_SIZE, 20)
TEXT_ZONE = int(FONT_SIZE * 2.5)
SCREEN_Y_WITH_TEXT = SCREEN_Y + TEXT_ZONE
BACKGROUND_COLOR = (200, 156, 156)
CELL_COLOR_rock = (0, 0, 0)
CELL_COLOR_fish = (60, 150, 200)
CELL_COLOR_prawn = (200, 100, 0)
TEXT_BACKGROUND_COLOR = (200, 100, 100)
TEXT_COLOR_1 = (0, 0, 0)
TEXT_COLOR_2 = (0, 0, 0)

# количество клеток по-горизонтали и по-вертикали
NUMBER_X = SCREEN_X // CELL_SIZE
NUMBER_Y = SCREEN_Y // CELL_SIZE

# параметры рождения, жизни и смерти
NEAR_TO_BORN = 3
NEAR_TO_LIVE = 2

# если считываем из файла
DATA_FILE = 'data.txt'

# класс клетки: тип и координаты
class Cell:
    def __init__(self, x, y, cell_type):
        self.cell_type = cell_type
        self.x = x * CELL_SIZE
        self.y = y * CELL_SIZE

    # рисование клетки
    def render(self, where):
        if self.cell_type == 'креветка':
            color = CELL_COLOR_prawn
            self.sur = pygame.Surface((CELL_SIZE, CELL_SIZE))
            self.sur.fill(color)
            where.blit(self.sur, (self.x, self.y))
        elif self.cell_type == 'рыба':
            color = CELL_COLOR_fish
            self.sur = pygame.Surface((CELL_SIZE, CELL_SIZE))
            self.sur.fill(color)
            where.blit(self.sur, (self.x, self.y))
        elif self.cell_type == 'скала':
            color = CELL_COLOR_rock
            self.sur = pygame.Surface((CELL_SIZE, CELL_SIZE))
            self.sur.fill(color)
            where.blit(self.sur, (self.x, self.y))

# класс ящика *Океан*
class Box:
    def __init__(self):
        self.box = [[Cell(x, y, '0') for y in range(NUMBER_Y)] for x in range(NUMBER_X)]
        self.near = [[[int(0) for z in range(1, 3)] for y in range(NUMBER_Y)] for x in range(NUMBER_X)]
        self.total = int(0)

    # рисование всех клеток
    def render(self, where):
        for x in range(NUMBER_X):
            for y in range(NUMBER_Y):
                self.box[x][y].render(where)

    # случайная конфигурация
    def random(self):

        for x in range(NUMBER_X):
            for y in range(NUMBER_Y):
                a = random.randint(0, 4)
                if a == 0:
                    self.box[x][y].cell_type = '0'
                elif a == 1:
                    self.box[x][y].cell_type = 'рыба'
                    self.total += 1
                elif a == 2:
                    self.box[x][y].cell_type = 'креветка'
                    self.total += 1
                elif a == 3:
                    self.box[x][y].cell_type = 'скала'

    # очистка
    def clear(self):
        self.__init__()

    # сохранение данных в файл
    def save(self, datafile):
        with open(datafile, 'w') as data:
            data.write(str(NUMBER_X) + '\n' + str(NUMBER_Y) + '\n')
            for x in range(NUMBER_X):
                for y in range(NUMBER_Y):
                    data.write(str(self.box[x][y].cell_type))

    # считывание из файла
    def load(self, datafile):
        try:
            with open(datafile, 'r') as data_file:
                data = data_file.read().split('\n')
                if int(data[0]) != NUMBER_X or int(data[1]) != NUMBER_Y:
                    print('Поле неверного размера, невозможно загрузить')
                else:
                    for x in range(NUMBER_X):
                        for y in range(NUMBER_Y):
                            if data[2][x * NUMBER_Y + y] == 'креветка':
                                self.box[x][y].cell_type = 'креветка'
                                self.total += 1
                            elif data[2][x * NUMBER_Y + y] == 'рыба':
                                self.box[x][y].cell_type = 'рыба'
                                self.total += 1
                            elif data[2][x * NUMBER_Y + y] == 'скала':
                                self.box[x][y].cell_type = 'скала'
                            else:
                                self.box[x][y].cell_type = '0'
        except:
            print('Файл для загрузки отсутствует или имеет неверный формат')

    # параллельное обновление конфигурации. Сперва подсчет соседей
    def update(self, where):
        for x in range(NUMBER_X):
            for y in range(NUMBER_Y):
                self.near[x][y][0] = 0
                self.near[x][y][1] = 0
                for i in range(-1, 2):
                    for j in range(-1, 2):

                        if j == 0 and i == 0:
                            continue

                        if (x + i) < 0:
                            temp_x = NUMBER_X - 1
                        elif (x + i) >= NUMBER_X:
                            temp_x = 0
                        else:
                            temp_x = x + i

                        if (y + j) < 0:
                            temp_y = NUMBER_Y - 1
                        elif (y + j) >= NUMBER_Y:
                            temp_y = 0
                        else:
                            temp_y = y + j

                        if self.box[temp_x][temp_y].cell_type == 'рыба':
                            self.near[x][y][0] += 1
                        elif self.box[temp_x][temp_y].cell_type == 'креветка':
                            self.near[x][y][1] += 1

        # теперь обновляем поле, зная информацию о соседях каждой клетки
        self.total = int(0)
        for x in range(NUMBER_X):
            for y in range(NUMBER_Y):
                if self.box[x][y].cell_type != 'креветка' and self.box[x][y].cell_type != 'рыба'\
                        and self.box[x][y].cell_type != 'скала':
                    if self.near[x][y][0] == NEAR_TO_BORN:
                        self.box[x][y].cell_type = 'рыба'
                    elif self.near[x][y][1] == NEAR_TO_BORN:
                        self.box[x][y].cell_type = 'креветка'
                elif (self.near[x][y][1] != NEAR_TO_LIVE and self.near[x][y][1] != NEAR_TO_BORN and \
                      self.box[x][y].cell_type == 'креветка') or \
                        (self.near[x][y][0] != NEAR_TO_LIVE and self.near[x][y][0] != NEAR_TO_BORN and \
                         self.box[x][y].cell_type == 'рыба'):
                    self.box[x][y].cell_type = '0'
                    self.total += -1
                if self.box[x][y].cell_type != '0':
                    self.total += 1

# приготовление поля
def prepare():

    # оговариваем выход из цикла и реакцию на команды. Считаем ходы
    exit = False
    global turn
    while not exit:

        # крестик - выход, пробел - запуск, r - рандомное заполнение, l - считать из файла, s - записать, c - очистить
        # оговариваем заполнение поля вручную
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                global new_game
                new_game = False
                exit = True
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_RETURN or event.key == pygame.K_SPACE:
                    exit = True
                elif event.key == pygame.K_r:
                    screen_box.random()
                elif event.key == pygame.K_c:
                    screen_box.clear()
                elif event.key == pygame.K_s:
                    screen_box.save(DATA_FILE)
                elif event.key == pygame.K_l:
                    screen_box.load(DATA_FILE)
            if event.type == pygame.MOUSEBUTTONDOWN:
                pos = pygame.mouse.get_pos()
                if pos[1] > TEXT_ZONE:
                    if screen_box.box[pos[0] // CELL_SIZE][(pos[1] - TEXT_ZONE) // CELL_SIZE].cell_type == '0':
                        screen_box.box[pos[0] // CELL_SIZE][(pos[1] - TEXT_ZONE) // CELL_SIZE].cell_type = 'рыба'
                    elif screen_box.box[pos[0] // CELL_SIZE][(pos[1] - TEXT_ZONE) // CELL_SIZE].cell_type == 'рыба':
                        screen_box.box[pos[0] // CELL_SIZE][(pos[1] - TEXT_ZONE) // CELL_SIZE].cell_type = 'креветка'
                    elif screen_box.box[pos[0] // CELL_SIZE][(pos[1] - TEXT_ZONE) // CELL_SIZE].cell_type == 'креветка':
                        screen_box.box[pos[0] // CELL_SIZE][(pos[1] - TEXT_ZONE) // CELL_SIZE].cell_type = 'скала'
                    elif screen_box.box[pos[0] // CELL_SIZE][(pos[1] - TEXT_ZONE) // CELL_SIZE].cell_type == 'скала':
                        screen_box.box[pos[0] // CELL_SIZE][(pos[1] - TEXT_ZONE) // CELL_SIZE].cell_type = '0'
                    else:
                        screen_box.box[pos[0] // CELL_SIZE][(pos[1] - TEXT_ZONE) // CELL_SIZE].cell_type = 'рыба'

        # организовываем наш ящик
        fon = pygame.Surface((SCREEN_X, SCREEN_Y))
        fon.fill(BACKGROUND_COLOR)
        screen.blit(fon, (0, 0))
        screen_box.render(screen)
        font_base = pygame.Surface((SCREEN_X, TEXT_ZONE))
        font_base.fill(TEXT_BACKGROUND_COLOR)
        score_font = pygame.font.SysFont("comicsansms", FONT_SIZE)
        result = score_font.render("Установите клетки и нажмите пробел для запуска игры. "
                                   "Ход: " + str(turn), 1, TEXT_COLOR_1)
        result_2 = score_font.render( "Для случайного распределения нажмите r, для очистки экрана нажмите c, для "
                                      "сохранения/загрузки поля нажмите s/l", 1, TEXT_COLOR_2)
        font_base.blit(result, (0, 0))
        font_base.blit(result_2, (0, FONT_SIZE))
        window.blit(font_base, (0, 0))
        window.blit(screen, (0, TEXT_ZONE))
        pygame.display.flip()

# основной цикл игры
def launch(score = 0):

    # запускаем таймер, оговариваем выход, считаем ходы
    timer = pygame.time.Clock()
    exit = False
    global turn

    n = int(input())

    while not exit:

        # во время игры мы можем или выйти, исчерпав ходы или нажав крестик
        if turn == n - 1:
            exit = True
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                global new_game
                new_game = False
                exit = True

        # наводим красоту в ящике, не забываем посчитать ход
        fon = pygame.Surface((SCREEN_X, SCREEN_Y))
        fon.fill(BACKGROUND_COLOR)
        screen.blit(fon, (0, 0))
        screen_box.render(screen)
        screen_box.update(screen)
        font_base = pygame.Surface((SCREEN_X, TEXT_ZONE))
        font_base.fill(TEXT_BACKGROUND_COLOR)
        score_font = pygame.font.SysFont("comicsansms", FONT_SIZE)
        result = score_font.render(
            "Нажмите пробел для паузы и/или режима установки доволнительны клеток. Ход: " + str(turn), 1, TEXT_COLOR_1)
        result_2 = score_font.render("Количество живых клеток: " + str(screen_box.total), 1, TEXT_COLOR_2)
        font_base.blit(result, (0, 0))
        font_base.blit(result_2, (0, FONT_SIZE))
        turn += 1
        window.blit(font_base, (0, 0))
        window.blit(screen, (0, TEXT_ZONE))
        pygame.display.flip()

if __name__ == '__main__':

    # создаем главное окно, называем его, делаем экран
    window = pygame.display.set_mode((SCREEN_X, SCREEN_Y_WITH_TEXT))
    pygame.display.set_caption('Игра "Жизнь"')
    screen = pygame.Surface((SCREEN_X, SCREEN_Y))
    pygame.font.init()

    # обнуляем ход и вхожим в игру
    turn = 0
    new_game = True
    screen_box = Box()
    screen_box.load(DATA_FILE)

    # главный цикл игры, запускаем подготовку, дальше входим в игру
    while new_game:
        prepare()
        if new_game:
            launch()
            
